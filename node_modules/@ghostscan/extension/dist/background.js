"use strict";
// GhostScan Browser Extension - Background Service Worker
console.log('ðŸ” GhostScan Background Service Worker loaded');
// Add a global message listener as a backup
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('ðŸ” GLOBAL MESSAGE LISTENER CALLED!');
    console.log('ðŸ” Global message:', message);
    if (message.action === 'PING') {
        console.log('ðŸ” PING received in global listener');
        sendResponse({ success: true, message: 'PONG from global listener' });
        return true;
    }
});
class GhostScanBackground {
    constructor() {
        this.isScanning = false;
        this.scanProgress = 0;
        this.visitedDomains = new Set();
        this.oauthConnections = new Map();
        console.log('ðŸ” GhostScanBackground constructor called');
        this.initializeListeners();
        console.log('ðŸ” GhostScanBackground initialization complete');
    }
    initializeListeners() {
        console.log('ðŸ” Initializing listeners...');
        // Handle extension installation
        chrome.runtime.onInstalled.addListener((details) => {
            console.log('GhostScan extension installed:', details.reason);
            if (details.reason === 'install') {
                this.onFirstInstall();
            }
        });
        // Handle messages from popup and content scripts
        console.log('ðŸ” Setting up message listener...');
        // Test if the listener is working by adding a simple test
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            console.log('ðŸ” MESSAGE LISTENER CALLED!');
            console.log('ðŸ” Background received message:', message);
            console.log('ðŸ” Sender:', sender);
            console.log('ðŸ” Message action:', message.action);
            console.log('ðŸ” Sender origin:', sender.origin);
            console.log('ðŸ” Sender tab:', sender.tab);
            // Handle the message
            this.handleMessage(message, sender, sendResponse);
            // Return true to keep message channel open for async response
            return true;
        });
        // Also try setting up a simple test listener
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            console.log('ðŸ” SIMPLE TEST LISTENER CALLED!');
            if (message.action === 'PING') {
                console.log('ðŸ” PING received in simple listener');
                sendResponse({ success: true, message: 'PONG from simple listener' });
                return true;
            }
        });
        console.log('ðŸ” Message listener set up successfully');
        // Test the message listener immediately after setup
        console.log('ðŸ” Testing message listener...');
        setTimeout(() => {
            console.log('ðŸ” Sending test message to self...');
            chrome.runtime.sendMessage({ action: 'PING' }, (response) => {
                console.log('ðŸ” Test message response:', response);
                if (chrome.runtime.lastError) {
                    console.log('ðŸ” Test message error:', chrome.runtime.lastError);
                }
            });
        }, 1000);
        // Track navigation to build domain history
        chrome.webNavigation.onCompleted.addListener((details) => {
            if (details.url) {
                const domain = new URL(details.url).hostname;
                this.visitedDomains.add(domain);
                console.log('Tracked domain:', domain);
            }
        });
        // Track cookie changes
        chrome.cookies.onChanged.addListener((changeInfo) => {
            console.log('Cookie changed:', changeInfo.cookie.name, 'on', changeInfo.cookie.domain);
        });
    }
    async onFirstInstall() {
        console.log('GhostScan extension first install');
        try {
            // Set up initial storage
            await chrome.storage.local.set({
                installed: true,
                firstScan: false,
                lastScan: null,
                privacyScore: 0,
                totalApps: 0,
                highRiskApps: 0,
                visitedDomains: [],
                oauthConnections: {}
            });
            console.log('Initial storage set up');
        }
        catch (error) {
            console.error('Error setting up initial storage:', error);
        }
    }
    async handleMessage(message, sender, sendResponse) {
        console.log('Handling message:', message.action);
        try {
            switch (message.action) {
                case 'START_SCAN':
                    const scanResult = await this.startScan();
                    console.log('Scan completed:', scanResult);
                    sendResponse({ success: true, data: scanResult });
                    break;
                case 'GET_SCAN_PROGRESS':
                    sendResponse({
                        success: true,
                        data: {
                            isScanning: this.isScanning,
                            progress: this.scanProgress
                        }
                    });
                    break;
                case 'TEST_CHROME_API':
                    const apiTest = await this.testChromeAPI();
                    sendResponse({ success: true, data: apiTest });
                    break;
                case 'GET_STORAGE_DATA':
                    const storageData = await this.getStorageData();
                    sendResponse({ success: true, data: storageData });
                    break;
                case 'CLEAR_SCAN_DATA':
                    await this.clearScanData();
                    sendResponse({ success: true, message: 'Scan data cleared' });
                    break;
                case 'PING':
                    console.log('ðŸ” PING received, sending PONG');
                    sendResponse({ success: true, message: 'PONG', timestamp: new Date() });
                    break;
                default:
                    console.log('Unknown action:', message.action);
                    sendResponse({ success: false, error: 'Unknown action' });
            }
        }
        catch (error) {
            console.error('Error handling message:', error);
            sendResponse({ success: false, error: error.message });
        }
    }
    async startScan() {
        if (this.isScanning) {
            throw new Error('Scan already in progress');
        }
        this.isScanning = true;
        this.scanProgress = 0;
        try {
            console.log('Starting real privacy scan...');
            // Step 1: Collect cookies
            await this.updateProgress('Collecting cookies...', 10);
            const cookies = await this.collectCookies();
            // Step 2: Analyze OAuth connections
            await this.updateProgress('Analyzing OAuth connections...', 30);
            const oauthData = await this.analyzeOAuthConnections();
            // Step 3: Check browsing history
            await this.updateProgress('Checking browsing history...', 50);
            const historyData = await this.analyzeBrowsingHistory();
            // Step 4: Detect tracking scripts
            await this.updateProgress('Detecting tracking scripts...', 70);
            const trackingData = await this.detectTrackingScripts();
            // Step 5: Generate comprehensive report
            await this.updateProgress('Generating privacy report...', 90);
            const scanResult = await this.generateComprehensiveReport(cookies, oauthData, historyData, trackingData);
            // Store scan result
            await this.storeScanResult(scanResult);
            await this.updateProgress('Scan completed!', 100);
            return scanResult;
        }
        finally {
            this.isScanning = false;
            this.scanProgress = 0;
        }
    }
    async updateProgress(message, progress) {
        console.log(message);
        this.scanProgress = progress;
        await new Promise(resolve => setTimeout(resolve, 300)); // Brief pause for UI
    }
    async collectCookies() {
        try {
            const cookies = await chrome.cookies.getAll({});
            console.log(`Collected ${cookies.length} cookies`);
            return cookies.map(cookie => ({
                name: cookie.name,
                domain: cookie.domain,
                value: cookie.value,
                secure: cookie.secure,
                httpOnly: cookie.httpOnly,
                sameSite: cookie.sameSite,
                expirationDate: cookie.expirationDate
            }));
        }
        catch (error) {
            console.error('Error collecting cookies:', error);
            return [];
        }
    }
    async analyzeOAuthConnections() {
        try {
            // Get current tab to check for OAuth providers
            const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
            const oauthProviders = ['google.com', 'facebook.com', 'github.com', 'twitter.com', 'linkedin.com'];
            const connections = [];
            for (const provider of oauthProviders) {
                const cookies = await chrome.cookies.getAll({ domain: provider });
                if (cookies.length > 0) {
                    connections.push({
                        provider,
                        cookies: cookies.length,
                        lastAccessed: new Date(),
                        dataTypes: this.getOAuthDataTypes(provider)
                    });
                }
            }
            console.log(`Found ${connections.length} OAuth connections`);
            return connections;
        }
        catch (error) {
            console.error('Error analyzing OAuth connections:', error);
            return [];
        }
    }
    async analyzeBrowsingHistory() {
        try {
            // Check if history API is available
            if (typeof chrome.history === 'undefined') {
                console.log('History API not available, skipping history analysis');
                return { totalVisits: 0, uniqueDomains: 0, topDomains: [] };
            }
            // Get recent browsing history (last 30 days)
            const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
            const history = await chrome.history.search({
                text: '',
                startTime: thirtyDaysAgo,
                maxResults: 1000
            });
            // Group by domain
            const domainStats = new Map();
            history.forEach(item => {
                if (item.url) {
                    const domain = new URL(item.url).hostname;
                    domainStats.set(domain, (domainStats.get(domain) || 0) + 1);
                }
            });
            console.log(`Analyzed ${history.length} history items from ${domainStats.size} domains`);
            return {
                totalVisits: history.length,
                uniqueDomains: domainStats.size,
                topDomains: Array.from(domainStats.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
            };
        }
        catch (error) {
            console.error('Error analyzing browsing history:', error);
            return { totalVisits: 0, uniqueDomains: 0, topDomains: [] };
        }
    }
    async detectTrackingScripts() {
        try {
            // This would require content script injection to detect tracking scripts
            // For now, we'll check for common tracking domains in cookies
            const trackingDomains = [
                'google-analytics.com',
                'facebook.com',
                'doubleclick.net',
                'googlesyndication.com',
                'amazon-adsystem.com',
                'bing.com'
            ];
            const trackingScripts = [];
            for (const domain of trackingDomains) {
                const cookies = await chrome.cookies.getAll({ domain });
                if (cookies.length > 0) {
                    trackingScripts.push(domain);
                }
            }
            console.log(`Detected ${trackingScripts.length} tracking domains`);
            return trackingScripts;
        }
        catch (error) {
            console.error('Error detecting tracking scripts:', error);
            return [];
        }
    }
    async generateComprehensiveReport(cookies, oauthData, historyData, trackingData) {
        const apps = [];
        let totalRiskScore = 0;
        // Process OAuth connections
        oauthData.forEach(oauth => {
            const app = {
                id: `oauth_${oauth.provider}`,
                name: this.getAppNameFromDomain(oauth.provider),
                domain: oauth.provider,
                riskLevel: this.calculateRiskLevel(oauth.cookies, oauth.dataTypes),
                dataTypes: oauth.dataTypes,
                hasBreaches: this.checkForBreaches(oauth.provider),
                thirdPartySharing: true,
                lastAccessed: oauth.lastAccessed,
                oauthProvider: oauth.provider,
                accountStatus: 'ACTIVE',
                passwordStrength: 'STRONG'
            };
            apps.push(app);
            totalRiskScore += this.calculateAppRiskScore(app);
        });
        // Process tracking domains
        trackingData.forEach(domain => {
            const app = {
                id: `tracking_${domain}`,
                name: this.getAppNameFromDomain(domain),
                domain: domain,
                riskLevel: 'HIGH',
                dataTypes: ['tracking', 'analytics'],
                hasBreaches: false,
                thirdPartySharing: true,
                lastAccessed: new Date(),
                accountStatus: 'UNKNOWN',
                passwordStrength: 'MEDIUM',
                trackingScripts: [domain]
            };
            apps.push(app);
            totalRiskScore += this.calculateAppRiskScore(app);
        });
        // Generate recommendations
        const recommendations = this.generateRecommendations(apps, cookies, historyData);
        return {
            apps,
            totalRiskScore: Math.min(totalRiskScore, 100),
            recommendations,
            timestamp: new Date(),
            scanType: 'COMPREHENSIVE'
        };
    }
    getOAuthDataTypes(provider) {
        const dataTypes = {
            'google.com': ['oauth_connection', 'email', 'profile', 'calendar', 'drive'],
            'facebook.com': ['oauth_connection', 'profile', 'friends', 'posts'],
            'github.com': ['oauth_connection', 'profile', 'repositories'],
            'twitter.com': ['oauth_connection', 'profile', 'tweets'],
            'linkedin.com': ['oauth_connection', 'profile', 'connections']
        };
        return dataTypes[provider] || ['oauth_connection', 'profile'];
    }
    getAppNameFromDomain(domain) {
        const names = {
            'google.com': 'Google',
            'facebook.com': 'Facebook',
            'github.com': 'GitHub',
            'twitter.com': 'Twitter',
            'linkedin.com': 'LinkedIn',
            'google-analytics.com': 'Google Analytics',
            'doubleclick.net': 'Google Ads',
            'googlesyndication.com': 'Google AdSense',
            'amazon-adsystem.com': 'Amazon Ads',
            'bing.com': 'Bing Ads'
        };
        return names[domain] || domain;
    }
    calculateRiskLevel(cookieCount, dataTypes) {
        let score = 0;
        score += cookieCount * 2;
        score += dataTypes.length * 10;
        if (score > 50)
            return 'CRITICAL';
        if (score > 30)
            return 'HIGH';
        if (score > 15)
            return 'MEDIUM';
        return 'LOW';
    }
    calculateAppRiskScore(app) {
        let score = 0;
        // Risk level scoring
        switch (app.riskLevel) {
            case 'CRITICAL':
                score += 30;
                break;
            case 'HIGH':
                score += 20;
                break;
            case 'MEDIUM':
                score += 10;
                break;
            case 'LOW':
                score += 5;
                break;
        }
        // Data types scoring
        score += app.dataTypes.length * 5;
        // Breach scoring
        if (app.hasBreaches)
            score += 15;
        // Third-party sharing scoring
        if (app.thirdPartySharing)
            score += 10;
        return score;
    }
    checkForBreaches(domain) {
        // This would integrate with a breach database API
        // For now, return mock data
        const breachedDomains = ['facebook.com', 'linkedin.com'];
        return breachedDomains.includes(domain);
    }
    generateRecommendations(apps, cookies, historyData) {
        const recommendations = [];
        const highRiskApps = apps.filter(app => app.riskLevel === 'HIGH' || app.riskLevel === 'CRITICAL');
        if (highRiskApps.length > 0) {
            recommendations.push(`Review privacy settings for ${highRiskApps.length} high-risk apps`);
        }
        if (cookies.length > 100) {
            recommendations.push('Consider clearing tracking cookies to improve privacy');
        }
        if (historyData.uniqueDomains > 50) {
            recommendations.push('You visit many different websites - consider using privacy-focused browsers');
        }
        const oauthApps = apps.filter(app => app.oauthProvider);
        if (oauthApps.length > 5) {
            recommendations.push('You have many OAuth connections - review and remove unused ones');
        }
        if (recommendations.length === 0) {
            recommendations.push('Great job! Your privacy settings look good');
        }
        return recommendations;
    }
    async testChromeAPI() {
        const tests = {
            runtime: typeof chrome.runtime !== 'undefined',
            storage: typeof chrome.storage !== 'undefined',
            cookies: typeof chrome.cookies !== 'undefined',
            tabs: typeof chrome.tabs !== 'undefined',
            webNavigation: typeof chrome.webNavigation !== 'undefined',
            history: typeof chrome.history !== 'undefined',
            identity: typeof chrome.identity !== 'undefined'
        };
        console.log('Chrome API tests:', tests);
        return tests;
    }
    async getStorageData() {
        try {
            const data = await chrome.storage.local.get(null);
            console.log('Storage data:', data);
            return data;
        }
        catch (error) {
            console.error('Error getting storage data:', error);
            return { error: error.message };
        }
    }
    async storeScanResult(scanResult) {
        try {
            await chrome.storage.local.set({
                lastScan: scanResult.timestamp,
                scanResult: scanResult,
                privacyScore: 100 - scanResult.totalRiskScore,
                totalApps: scanResult.apps.length,
                highRiskApps: scanResult.apps.filter((app) => app.riskLevel === 'HIGH' || app.riskLevel === 'CRITICAL').length
            });
            console.log('Scan result stored');
        }
        catch (error) {
            console.error('Error storing scan result:', error);
        }
    }
    async clearScanData() {
        try {
            await chrome.storage.local.clear();
            await this.onFirstInstall(); // Reset to initial state
            console.log('Scan data cleared');
        }
        catch (error) {
            console.error('Error clearing scan data:', error);
        }
    }
}
// Initialize the background service
new GhostScanBackground();
//# sourceMappingURL=background.js.map