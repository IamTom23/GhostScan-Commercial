"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const helmet_1 = __importDefault(require("helmet"));
const shared_1 = require("@ghostscan/shared");
const ai_1 = require("@ghostscan/ai");
const app = (0, express_1.default)();
const PORT = process.env.PORT || 3001;
// Middleware
app.use((0, helmet_1.default)());
app.use((0, cors_1.default)());
app.use(express_1.default.json());
// Initialize AI services
const threatAnalyzer = new ai_1.ThreatAnalyzer();
const aiAssistant = new ai_1.AIAssistant();
const breachMonitor = new ai_1.BreachMonitor();
const ghostDetector = new ai_1.GhostProfileDetector();
// Mock database (replace with real database in production)
let users = [];
let scanResults = [];
let privacyRequests = [];
let breachAlerts = [];
let ghostProfiles = [];
// Routes
// Health check
app.get('/health', (req, res) => {
    res.json({ status: 'OK', timestamp: new Date().toISOString() });
});
// User Management
app.post('/api/users', (req, res) => {
    const { email } = req.body;
    if (!email) {
        return res.status(400).json({ error: 'Email is required' });
    }
    const existingUser = users.find(u => u.email === email);
    if (existingUser) {
        return res.json(existingUser);
    }
    const newUser = {
        id: `user_${Date.now()}`,
        email,
        riskScore: 0,
        totalApps: 0,
        highRiskApps: 0,
        preferences: {
            breachAlerts: true,
            weeklyReports: true,
            autoPrivacyRequests: false,
        },
    };
    users.push(newUser);
    res.status(201).json(newUser);
});
app.get('/api/users/:userId', (req, res) => {
    const user = users.find(u => u.id === req.params.userId);
    if (!user) {
        return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
});
// Scanning
app.post('/api/scan', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId, scanType = 'COMPREHENSIVE' } = req.body;
    if (!userId) {
        return res.status(400).json({ error: 'User ID is required' });
    }
    try {
        // Simulate scanning process
        const mockApps = [
            {
                id: '1',
                name: 'Canva',
                domain: 'canva.com',
                riskLevel: 'MEDIUM',
                dataTypes: ['personal', 'creative'],
                hasBreaches: false,
                thirdPartySharing: true,
                lastAccessed: new Date('2024-01-15'),
                oauthProvider: 'Google',
                accountStatus: 'ACTIVE',
                passwordStrength: 'STRONG',
            },
            {
                id: '2',
                name: 'Grammarly',
                domain: 'grammarly.com',
                riskLevel: 'HIGH',
                dataTypes: ['personal', 'writing', 'documents'],
                hasBreaches: true,
                thirdPartySharing: true,
                lastAccessed: new Date('2024-01-10'),
                accountStatus: 'ACTIVE',
                passwordStrength: 'WEAK',
                isReused: true,
            },
            {
                id: '3',
                name: 'Adobe Creative Cloud',
                domain: 'adobe.com',
                riskLevel: 'LOW',
                dataTypes: ['personal', 'creative'],
                hasBreaches: false,
                thirdPartySharing: false,
                lastAccessed: new Date('2024-01-20'),
                accountStatus: 'ACTIVE',
                passwordStrength: 'STRONG',
            },
        ];
        // Analyze each app
        const analyzedApps = yield Promise.all(mockApps.map((app) => __awaiter(void 0, void 0, void 0, function* () {
            const analysis = yield threatAnalyzer.analyzeApp(app);
            return Object.assign(Object.assign({}, app), { riskLevel: analysis.riskLevel });
        })));
        const scanResult = {
            apps: analyzedApps,
            totalRiskScore: (0, shared_1.calculateRiskScore)(analyzedApps),
            recommendations: [
                'Change passwords for breached accounts',
                'Enable two-factor authentication',
                'Review privacy settings for high-risk apps',
            ],
            timestamp: new Date(),
            scanType: scanType,
        };
        scanResults.push(scanResult);
        // Update user profile
        const userIndex = users.findIndex(u => u.id === userId);
        if (userIndex !== -1) {
            users[userIndex] = Object.assign(Object.assign({}, users[userIndex]), { riskScore: scanResult.totalRiskScore, totalApps: analyzedApps.length, highRiskApps: analyzedApps.filter(app => app.riskLevel === 'HIGH' || app.riskLevel === 'CRITICAL').length, lastScanDate: new Date() });
        }
        res.json(scanResult);
    }
    catch (error) {
        console.error('Scan error:', error);
        res.status(500).json({ error: 'Scan failed' });
    }
}));
app.get('/api/scan/:userId/latest', (req, res) => {
    const userScans = scanResults.filter(s => s.apps.some(app => app.id === req.params.userId));
    const latestScan = userScans[userScans.length - 1];
    if (!latestScan) {
        return res.status(404).json({ error: 'No scan results found' });
    }
    res.json(latestScan);
});
// Apps Management
app.get('/api/apps/:userId', (req, res) => {
    const userScans = scanResults.filter(s => s.apps.some(app => app.id === req.params.userId));
    const latestScan = userScans[userScans.length - 1];
    if (!latestScan) {
        return res.json({ apps: [] });
    }
    res.json({ apps: latestScan.apps });
});
app.get('/api/apps/:userId/:appId', (req, res) => {
    const { userId, appId } = req.params;
    const userScans = scanResults.filter(s => s.apps.some(app => app.id === userId));
    const latestScan = userScans[userScans.length - 1];
    if (!latestScan) {
        return res.status(404).json({ error: 'App not found' });
    }
    const app = latestScan.apps.find(a => a.id === appId);
    if (!app) {
        return res.status(404).json({ error: 'App not found' });
    }
    res.json(app);
});
// Breach Monitoring
app.get('/api/breaches/:userId', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId } = req.params;
    const user = users.find(u => u.id === userId);
    if (!user) {
        return res.status(404).json({ error: 'User not found' });
    }
    try {
        // Check for breaches
        const breaches = yield breachMonitor.checkForBreaches(user.email);
        // Add mock breach for demonstration
        const mockBreach = {
            id: `breach_${Date.now()}`,
            appId: '2', // Grammarly
            breachDate: new Date('2024-01-05'),
            dataTypes: ['emails', 'passwords'],
            severity: 'HIGH',
            description: 'Data breach affecting 3.2M users',
            isNew: true,
        };
        const userBreaches = [mockBreach, ...breaches];
        breachAlerts.push(...userBreaches);
        res.json({ breaches: userBreaches });
    }
    catch (error) {
        console.error('Breach check error:', error);
        res.status(500).json({ error: 'Failed to check breaches' });
    }
}));
// Ghost Profile Detection
app.get('/api/ghosts/:userId', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId } = req.params;
    const user = users.find(u => u.id === userId);
    if (!user) {
        return res.status(404).json({ error: 'User not found' });
    }
    try {
        const ghosts = yield ghostDetector.detectGhostProfiles(user.email);
        // Add mock ghost profile for demonstration
        const mockGhost = {
            id: `ghost_${Date.now()}`,
            platform: 'LinkedIn',
            email: user.email,
            username: 'user_profile',
            foundVia: 'SHADOW_PROFILE',
            confidence: 0.95,
            dataExposed: ['name', 'email', 'work_history'],
        };
        const userGhosts = [mockGhost, ...ghosts];
        ghostProfiles.push(...userGhosts);
        res.json({ ghosts: userGhosts });
    }
    catch (error) {
        console.error('Ghost detection error:', error);
        res.status(500).json({ error: 'Failed to detect ghost profiles' });
    }
}));
// Privacy Requests
app.post('/api/privacy-requests', (req, res) => {
    const { userId, appId, type } = req.body;
    if (!userId || !appId || !type) {
        return res.status(400).json({ error: 'User ID, App ID, and type are required' });
    }
    const privacyRequest = {
        id: `request_${Date.now()}`,
        type: type,
        appId,
        userId,
        status: 'PENDING',
        createdAt: new Date(),
    };
    privacyRequests.push(privacyRequest);
    res.status(201).json(privacyRequest);
});
app.get('/api/privacy-requests/:userId', (req, res) => {
    const userRequests = privacyRequests.filter(r => r.userId === req.params.userId);
    res.json({ requests: userRequests });
});
// AI Assistant
app.post('/api/assistant/query', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId, question, context } = req.body;
    if (!userId || !question) {
        return res.status(400).json({ error: 'User ID and question are required' });
    }
    try {
        const query = {
            id: `query_${Date.now()}`,
            question,
            context: context || {},
            timestamp: new Date(),
        };
        const response = yield aiAssistant.processQuery(query);
        res.json({
            queryId: query.id,
            response,
            timestamp: new Date(),
        });
    }
    catch (error) {
        console.error('AI Assistant error:', error);
        res.status(500).json({ error: 'Failed to process query' });
    }
}));
// Email Scanner
app.post('/api/email-scan', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId, email } = req.body;
    if (!userId || !email) {
        return res.status(400).json({ error: 'User ID and email are required' });
    }
    try {
        // Simulate email scanning
        const emailScanResult = {
            id: `email_scan_${Date.now()}`,
            email,
            subscriptions: [
                {
                    service: 'Netflix',
                    frequency: 'monthly',
                    lastEmail: new Date('2024-01-20'),
                    category: 'entertainment',
                },
                {
                    service: 'Spotify',
                    frequency: 'monthly',
                    lastEmail: new Date('2024-01-18'),
                    category: 'entertainment',
                },
            ],
            signups: [
                {
                    service: 'Canva',
                    signupDate: new Date('2024-01-15'),
                    status: 'ACTIVE',
                },
                {
                    service: 'Grammarly',
                    signupDate: new Date('2024-01-10'),
                    status: 'ACTIVE',
                },
            ],
        };
        res.json(emailScanResult);
    }
    catch (error) {
        console.error('Email scan error:', error);
        res.status(500).json({ error: 'Failed to scan email' });
    }
}));
// Privacy Insights
app.get('/api/insights/:userId', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { userId } = req.params;
    const userScans = scanResults.filter(s => s.apps.some(app => app.id === userId));
    const latestScan = userScans[userScans.length - 1];
    if (!latestScan) {
        return res.json({ insights: [] });
    }
    try {
        const insights = yield aiAssistant.generatePrivacyInsights(latestScan.apps);
        res.json({ insights });
    }
    catch (error) {
        console.error('Insights error:', error);
        res.status(500).json({ error: 'Failed to generate insights' });
    }
}));
// Dashboard Stats
app.get('/api/dashboard/:userId', (req, res) => {
    const { userId } = req.params;
    const user = users.find(u => u.id === userId);
    if (!user) {
        return res.status(404).json({ error: 'User not found' });
    }
    const userScans = scanResults.filter(s => s.apps.some(app => app.id === userId));
    const latestScan = userScans[userScans.length - 1];
    const userBreaches = breachAlerts.filter(b => b.appId === userId);
    const userGhosts = ghostProfiles.filter(g => g.email === user.email);
    const stats = {
        user,
        latestScan: latestScan || null,
        breachCount: userBreaches.length,
        ghostCount: userGhosts.length,
        newBreaches: userBreaches.filter(b => b.isNew).length,
    };
    res.json(stats);
});
// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
});
// 404 handler
app.use((req, res) => {
    res.status(404).json({ error: 'Route not found' });
});
app.listen(PORT, () => {
    console.log(`ğŸš€ GhostScan Personal API running on port ${PORT}`);
    console.log(`ğŸ“Š Health check: http://localhost:${PORT}/health`);
    console.log(`ğŸ” API Documentation: http://localhost:${PORT}/api`);
});
//# sourceMappingURL=index.js.map